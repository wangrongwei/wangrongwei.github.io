<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wangrongwei&apos;s world</title>
    <description>个人博客</description>
    <link>http://wangrongwei.com/</link>
    <atom:link href="http://wangrongwei.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 14 Nov 2021 03:18:31 +0800</pubDate>
    <lastBuildDate>Sun, 14 Nov 2021 03:18:31 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>如何读写aarch64的系统寄存器</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2021/09/17/how-to-read-or-write-register-in-aarch64.html&quot;&gt;http://wangrongwei.com/2021/09/17/how-to-read-or-write-register-in-aarch64.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;去年，我在alibaba写了一个关于读写arm64系统寄存器的一个工具，大概过去好几个月了，最近又更新了一下其中的驱动模块。
在这里简单介绍一下如何使用这个工具。&lt;/p&gt;

&lt;h1 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h1&gt;

&lt;p&gt;快速安装：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/alibaba/system-register-tools
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;system-register-tools &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make all &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，system-register-tools所依赖的内核模块也在该仓库下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;msr-arm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;insmod msr.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成以上两个步骤，即可使用rdasr和wrasr命令。&lt;/p&gt;

&lt;p&gt;如何读寄存器：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rdasr &lt;span class=&quot;nt&quot;&gt;-p0&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; MPIDR_EL1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rdasr &lt;span class=&quot;nt&quot;&gt;-p1&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; MPIDR_EL1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面两个命令分别读取core0、core1的MPIDR_EL1。&lt;/p&gt;

&lt;p&gt;如何写寄存器：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wrasr &lt;span class=&quot;nt&quot;&gt;-p0&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; PMCNTENCLR_EL0 0x80000000
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wrasr &lt;span class=&quot;nt&quot;&gt;-p1&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; PMCNTENCLR_EL0 0x80000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里，rdasr和wrasr的使用大致就是如此。&lt;/p&gt;

&lt;h1 id=&quot;note&quot;&gt;Note&lt;/h1&gt;

&lt;p&gt;由于在实现msr-arm模块的过程中，借助修改代码段的方式来实现不同寄存器的读写。这种修改代码段存在一定的风险。建议线上系统谨慎使用。&lt;/p&gt;

&lt;h1 id=&quot;相关工具&quot;&gt;相关工具&lt;/h1&gt;

&lt;p&gt;x86：&lt;a href=&quot;https://github.com/intel/msr-tools&quot;&gt;https://github.com/intel/msr-tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;systemtap：&lt;a href=&quot;https://github.com/wangrongwei/stap/blob/master/read-msr-aarch64.stp&quot;&gt;https://github.com/wangrongwei/stap/blob/master/read-msr-aarch64.stp&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 17 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2021/09/17/how-to-read-or-write-register-in-aarch64.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2021/09/17/how-to-read-or-write-register-in-aarch64.html</guid>
        
        <category>aarch64</category>
        
        <category>系统寄存器</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Linux内核之内存规整</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2021/03/25/what-is-memory-compaction.html&quot;&gt;http://wangrongwei.com/2021/03/25/what-is-memory-compaction.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是我之前在学习内存memory compaction（内存规整）代码后，整理的一篇关于内存规整的介绍：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/docs/share/b0c7c2db-ea93-43b4-bdb9-222f27091863?# 《分配连续页失败了怎么办？内存规整！》&quot;&gt;分配连续页失败了怎么办？内存规整！&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2021/03/25/what-is-memory-compaction.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2021/03/25/what-is-memory-compaction.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>vmcore自动分析工具</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章转自阿里云开发者社区&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;https://developer.aliyun.com/article/719723?spm=a2c6h.13262185.0.0.21e82cd2ICg6IN&quot;&gt;https://developer.aliyun.com/article/719723?spm=a2c6h.13262185.0.0.21e82cd2ICg6IN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;vmcore分析工具的需求变化&quot;&gt;vmcore分析工具的需求变化&lt;/h2&gt;

&lt;p&gt;解决内核宕机、修复线上问题以及优化性能瓶颈是各操作系统团队工程师日常工作之一，其中大量工作依赖于crash工具对vmcore进行分析，但是应用规模以及场景的变化对其提出了新的需求。这种需求对开发者和集群运维而言，反映出不同的问题。对于开发者而言，crash工具可以满足查看vmcore中几乎所有数据的需求，例如全局变量、调度子系统以及cgroup等相关数据，但是将各类数据关联起来，需要工程师多次手动操作查看数据并与内核源码结合，其中涉及复杂的数据结构和领域知识，门槛太高，同时存在数据显示的友好程度较低等问题；对于集群运维效率而言，频繁产生的vmcore存在大量相似问题的vmcore，需求一种更加高效、精准的vmcore分析工具对频率较高的vmcore进行特征分析，以提高解决系统宕机问题的效率，现有的vmcollect系统采用panic栈进行相似度匹配，错误率较高，无法满足以上需求。&lt;/p&gt;

&lt;p&gt;接下来，本文将对当前vmcore分析工具存在的问题进行展开，并向大家介绍一个vmcore自动分析工具，即&lt;strong&gt;VAATools（Vmcore Automatic Analysis Tools）&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;当前vmcore分析工具存在的问题&quot;&gt;当前vmcore分析工具存在的问题&lt;/h2&gt;

&lt;p&gt;当前，除crash工具以外，也存在其他大量基于Python、shell、perl等语言的vmcore分析工具，表1对目前已有的vmcore分析工具进行了一个简单对比。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表 1 vmcore分析工具对比&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;crash&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;crash-Python&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;pykdump&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;crash-extscript&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;analyzevmcore&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;drgn&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;语言&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;c&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;c/Python&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;c/Python&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;c/perl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;shell&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;C&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;库&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;libkdumpfile&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;libkdumpfile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;crash&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;交互方式&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;嵌套&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;套接字&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;直接&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多vmcore支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;友好程度&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;较低&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;较低&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;表1从开发语言、依赖库以及交互方式等6个方面对当前已有的6种vmcore分析工具进行总结。在以上vmcore分析工具中，crash-extscript和analyzevmcore分别采用了perl或shell对crash进行扩展，crash-extscript采用套接字与crash进行交互，这种交互的方式非必须和唯一，可以进行优化，analyzevmcore没有较明显的特点和优点可以介绍。Pykdump提供了在crash中使用python编写命令的方法，这种方式给了工程师较大的使用和自由实现命令的空间，依赖Python可以轻松、快速的实现多种数据的对比和关联。drgn与Pykdump较相似，但不依赖于crash获取vmcore种数据，其操作方式更为灵活，语法较多。&lt;/p&gt;

&lt;p&gt;以上6种工具提供了分析vmcore文件的基本方式，但在为vmcollect系统选择vmcore分析工具时，还需满足多个vmcore文件分析功能，同时具备更精准的vmcore分析能力，以满足集群中大量相似vmcore文件特征匹配的场景需求。&lt;/p&gt;

&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;

&lt;p&gt;针对以上问题，我们设计了一个VAATools工具，其功能包括：&lt;/p&gt;

&lt;p&gt;1）分析获取多个或单个vmcore文件信息，支持报表信息显示task、cgroup等变量重要信息；&lt;/p&gt;

&lt;p&gt;2）支持编写Python脚本对内核中重要数据进行获取和处理；&lt;/p&gt;

&lt;p&gt;3）提供几个参考的使用Python编写的命令；&lt;/p&gt;

&lt;p&gt;在VAATools中，提供了多个vmcore文件分析功能和可支持利用Python设计crash命令。接下来，对这些功能进行一个简单的介绍。&lt;/p&gt;

&lt;h3 id=&quot;分析多个vmcore文件&quot;&gt;分析多个vmcore文件&lt;/h3&gt;

&lt;p&gt;输入vmcores所在文件夹，将各vmcore分析结果可输出到“.crash”文件下，命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VAATcrash -d /&amp;lt;path-to-vmcore-dir&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果包含bt、各cpu中runqueues、cfs_rq参数表格显示信息以及当前进程信息。同时，也将runq命令输出信息也保存到结果文件中，如文未链接。&lt;/p&gt;

&lt;p&gt;VAATcrash的其他功能可借助’-h’选项查看。&lt;/p&gt;

&lt;h3 id=&quot;使用python编写的新命令&quot;&gt;使用Python编写的新命令&lt;/h3&gt;

&lt;p&gt;在VAATools中command目录下，提供了采用Python编写的cpu、锁信息、cgroup信息等命令。这些命令将平时需要多次操作crash命令并同时需要阅读Linux内核查看数据关联的过程进行封装为一个命令。这些命令与crash自带的命令在功能上无明显的差异，但由于Python的语言环境，设计一个Python命令可能更加容易和较快的处理一些数据和变量间关联性。&lt;/p&gt;

&lt;p&gt;接下来，对command下的几个命令进行展示。&lt;/p&gt;

&lt;p&gt;1）cpuinfo命令可显示vmcore中core分布以及tlb状态。如图3-1，图3-2所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/7daa83d2d805acae26af8a4d2892a362.png&quot; alt=&quot;图 3-1 cpuinfo命令（cpuinfo -i）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 3-1 cpuinfo命令（cpuinfo -i）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/01088614a5bc7ba7b5d1c32afb99635c.png&quot; alt=&quot;图 3-2 cpuinfo命令（cpuinfo -t）&quot; /&gt;
&lt;strong&gt;图 3-2 cpuinfo命令（cpuinfo -t）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2）可解析占用某个锁的进程信息。如图3-3所示查看发生panic时，占用“cgroup_mutex”的进程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/cb02a1a9de0714b925d04acdcf1cd63c.png&quot; alt=&quot;cb02a1a9de0714b925d04acdcf1cd63c.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 3-3 lockinfo命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3）表格形式显示vmcore中多个同类型数据，可以明显观察出异常值。如图3-4所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/9f717fa45aa1340359bcce96c2690fcc.png&quot; alt=&quot;9f717fa45aa1340359bcce96c2690fcc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 3-4 tasktableinfo命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;4）层次结构类型数据显示，例如显示cgroup层次结构，如图3-5所示，显示出各级cpuset、cpu等，同时可以获取各层cpus、mem等参数值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/0f119ace64923e8b120dd318bbe446fb.png&quot; alt=&quot;0f119ace64923e8b120dd318bbe446fb.png&quot; /&gt;
&lt;strong&gt;图 3-5 cgroupinfo命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上命令在实现过程中还可以直接通过相关的接口，如exec_crash_command，调用crash原命令，对原命令打印的数据进行处理。&lt;/p&gt;

&lt;h2 id=&quot;深入了解vaatools&quot;&gt;深入了解VAATools&lt;/h2&gt;

&lt;p&gt;VAATools主要实现单个以及多个vmcore的分析功能，同时尽量采用Python进行开发，保证代码的维护性，实现较高的可视化数据显示方式。接下来，对VAATools背后的框架以及原理进行介绍。&lt;/p&gt;

&lt;h3 id=&quot;vaatools原理&quot;&gt;VAATools原理&lt;/h3&gt;

&lt;p&gt;为实现&lt;strong&gt;vmcollect&lt;/strong&gt;系统上高效的vmcore分析工具，我们将crash中加入”Python”的元素，借助Python便于解决后续的数据处理、对比，图表显示、以及为后续部署模式匹配、机器学习算法部署搭建友好的框架。VAATools框架如图4-1所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/685cdf4d94e856d32ce38a82a3706796.png&quot; alt=&quot;ef24bad251881372bc9ef22a2fcd20cc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 4-1 VAATools设计草图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在VAATools中，顶层VAATcrash命令主要采用Python语言进行设计，并通过Python中的subprocess库启动一个crash进程并通过管道非阻塞的方式接收crash返回的数据。&lt;/p&gt;

&lt;p&gt;中间层epython命令，主要基于crash提供的命令扩展功能，并借助C语言与Python之间的相互调用接口实现epython调用Python版自定义命令。另外，顶层VAATcrash通过传入的参数控制epython选择不同的vmcore分析方式，比如单个vmcore以及多个vmcore。&lt;/p&gt;

&lt;p&gt;当前，可借鉴和使用的项目主要为开源的pykdump，其提供的各类接口满足epython与自定义命令间的功能需求。&lt;/p&gt;

&lt;h3 id=&quot;c与python间相互嵌套&quot;&gt;C与Python间相互嵌套&lt;/h3&gt;

&lt;p&gt;在VAATools中多处存在C语言中调用Python，Python中调用C的代码。在VAATools的C与Python两种语言嵌套方式的开发过程中，主要参考和借鉴了Pykdump中相关设计。VAATools依赖于Pykdump提供的库文件&lt;/p&gt;

&lt;h3 id=&quot;vaatools中存在的性能问题&quot;&gt;VAATools中存在的性能问题&lt;/h3&gt;

&lt;p&gt;利用Python设计VAATools，在开发上简单和快速，但是也带来了处理速率慢的问题，尤其在处理vmcore文件较多，或查看整理的变量较多时，整体处理完成的时间较长。&lt;/p&gt;

&lt;p&gt;在VAATools设计初，已经从原先的Python与crash间进程交互方式改进为现在的Python直接调用crash内函数，同时转移多个数据获取方式到crash内部的方式。通过统计获取各种数据的等待时间，我们可以了解到当前VAATools的性能信息，图4-2为VAATools优化前后获取rq、cfs、task等数据的等待时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/00d87e2e8b50d89542c82ea46d700c37.png&quot; alt=&quot;c897add9d8c8d3e6e0b2fcddc8350555.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 4-2 VAATools性能优化前后对比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从上图的确可以看出优化后，VAATools改进不少，但是cfs的等待延时还是偏大，其原因在于获取cfs数据时，解析的成员变量较多。因此，如果要获取的某类数据过多，将等待很长一段时间才获取结果文件，大幅度降低debug效率。&lt;/p&gt;

&lt;p&gt;目前，VAATools的性能还可以在VAATools的架构调整以后，有较大的提升空间。&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;

&lt;p&gt;1）改善Python与crash间的交互；&lt;/p&gt;

&lt;p&gt;目前，VAATools中，最外层VAATcrash命令与crash间还存在一层通过管道获取数据的方式，通过管道获取crash的数据时，需要设置等待延时，从而带来性能问题。后期可以将这一层完全改进为函数调用的方式，不再需要启动crash进程这一过程。&lt;/p&gt;

&lt;p&gt;2）vmcore特征提取；&lt;/p&gt;

&lt;p&gt;提取vmcore中宕机原因的特征，从而实现后续对大量的vmcore文件进行相似度分析，识别相同问题的vmcore的目标。&lt;/p&gt;

&lt;p&gt;3）考虑是否可以将机器学习引入到vmcore；&lt;/p&gt;

&lt;p&gt;将机器学习用于提取vmcore特征、训练vmcore特征匹配模型可能是一种vmcore特征匹配精度更高的方法。&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;[1] http://vmcore.alibaba-inc.com/&lt;/p&gt;

&lt;p&gt;[1] https://people.redhat.com/anderson/&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&quot;https://sourceforge.net/projects/pykdump/?spm=a2c6h.12873639.0.0.69e56091MTLjpX&quot;&gt;https://sourceforge.net/projects/pykdump/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] https://github.com/jeffmahoney/crash-python&lt;/p&gt;

&lt;p&gt;[4] https://github.com/osandov/drgn&lt;/p&gt;

&lt;p&gt;[5] https://github.com/g23guy/supportutils&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/09/29/vmcore-auto-analysis.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/09/29/vmcore-auto-analysis.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>DIMM的层次结构</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/06/25/DIMM.html&quot;&gt;http://wangrongwei.com/2020/06/25/DIMM.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DIMM的层次结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://wangrongwei.com/images/DIMM-structure.svg&quot; alt=&quot;svg&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 25 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/06/25/DIMM.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/06/25/DIMM.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>一个基于i386的系统内核</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部
作者：lollipop
本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/06/20/UNIX386.html&quot;&gt;http://wangrongwei.com/2020/06/20/UNIX386.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;一个简答的OS，目前已完成到进程调度模型，其他部分正在完善中。&lt;/p&gt;

&lt;h2 id=&quot;unix386&quot;&gt;UNIX386&lt;/h2&gt;

&lt;h3 id=&quot;boot&quot;&gt;boot&lt;/h3&gt;

&lt;p&gt;在i386架构中，首先CPU上电运行在实模式下，将执行存储在ROM中的BIOS，这段BIOS将会进行简单的中断初始化，建立中断向量表（如int 0x20），随后便跳转到0x7c00执行，这段代码需保证在512Byte内（主要是这个拷贝过程是BIOS已经限定的，只拷贝一个扇区的数据）。0x7c00这段代码由我们设计，因此，我们在这只有512Byte大小的代码中，需要将后续的OS代码拷贝到可用的内存中。这段流程如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://wangrongwei.com/images/image-20200627162350561.png&quot; alt=&quot;image-20200627162350561&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们将前后拷贝的OS代码分别称为boot.bin的前512Byte和boot.bin剩余部分。&lt;/p&gt;

&lt;p&gt;实模式下地址空间分布：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://wangrongwei.com/images/image-20200627160159766.png&quot; alt=&quot;image-20200627160159766&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该图来源于https://wiki.osdev.org/Memory_Map_(x86)#BIOS_Data_Area_.28BDA.29&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段实模式下地址分布图主要用来辅助理解i386下boot.bin和kernel.bin如此设计的理由。&lt;/p&gt;

&lt;p&gt;以下是实际启动相关代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;ORG	BOOT_ADDR	;必须是这个地址
;初始化段SS=0 DS=0 ES=0 SP指向程序加载的地址
;因为程序加载的地址是0x7c00，所以我们的段地址必须是0，
;不然地址就不是0x7c00
	MOV	AX,CS
	MOV	SS,AX
	MOV	SP,BOOT_ADDR
	MOV	DS,AX
	MOV	ES,AX
;
;The second stage
;	Now ,load kernel from img
;
	MOV	SI,msg
putloop:
	MOV	AL,[SI]
	ADD	SI,1
	CMP	AL,0
	JE	Read_Sector
	MOV	AH,0x0e
	MOV	BX,0x0f
	INT	0x10		;ִ执行BIOS中断0x10
	JMP	putloop

Read_Sector:
	MOV	SI,msg_1	;打开成功显示字符
Read:
	MOV	AL,[SI]
	ADD	SI,1
	CMP	AL,0
	JE	Read_Ok
	MOV	AH,0x0e
	MOV	BX,0x0f
	INT	0x10		;ִ执行BIOS中断0x10
	JMP	Read
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在i386中，BIOS上电一段时间进行内存划分，中断向量表的初始化，最终将会跳转到0x7c00执行。boot相关的代码即为跳转到0x7c00后待执行的代码。这段代码将使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;ORG	BOOT_ADDR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表明后续的代码将会被拷贝到内存的0x7c00处。&lt;/p&gt;

&lt;h3 id=&quot;实模式跳转保护模式&quot;&gt;实模式跳转保护模式&lt;/h3&gt;

&lt;p&gt;在实模式下，OS只能使用有限的地址空间，以及有限的寄存器资源，无法进行后续的内存管理、进程调度，因此我们需要向保护模式跳转。&lt;/p&gt;

&lt;p&gt;以下是实际进入保护模式的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;;
;The third stage
;	goto PM mode
;
goto_PM:
	MOV	AL,0X03
	MOV	AH,0X00
	INT	0x10

	MOV	AL,0xFF
	OUT	0x21,AL
	NOP
	OUT	0xa1,AL

	CLI

;开始移动第二部分内核（0x7c00+512后面的代码）到0x0地址，因此原中断服务程序被覆盖
move_start:
        CLI
        MOV     AX,0x0800       ;源地址
        MOV     DS,AX
        MOV     AX,0x0500       ;目的地址
        MOV     ES,AX

        MOV     CX,0x7000       ;表示复制的字节x/2
        SUB     SI,SI           ;DS:SI---&amp;gt;ES:DI
        SUB     DI,DI
        REP     MOVSW   	;在linux-0.1.1中使用rep movw的intel的格式
move_end:
        MOV     AX,CS   	;还原改变的两个段
        MOV     ES,AX
        MOV     DS,AX
;
; OPEN A20
;
	CALL	waitkbd_8042
	MOV	AL,0xd1      	;写命令
	OUT	0x64,AL
	CALL	waitkbd_8042
	MOV	AL,0xdf
	OUT	0x60,AL
	CALL	waitkbd_8042 	;打开A20

    CLI
    ;由于最开始编译这个程序是按0x7c00为偏移地址的，
    ;所以移动到0x0地址以后，需要重新计算GDTR0存储的地址
	LGDT	[GDTR0-0x7c00]

    IN      AL,92h
    OR      AL,0x02
	OUT     92h,AL

    MOV	EAX,CR0
	AND	EAX,0x7fffffff
	OR	AL,1
	MOV	CR0,EAX                 ;打开段级保护，不开分页机制
;程序执行到这里结束，跳转到init/kernel.asm（即移动到0x0处的代码）执行
	JMP	dword 0x08:0x5000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，主要涉及三个过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;移动代码：接下来的一段时间里，我们不在需要BIOS所创建的中断向量表，因此我们可以将boot.bin这段代码移动到起始地址为0x00；&lt;/li&gt;
  &lt;li&gt;打开A20：1MByte的地址空间是不够使用的，因此在kernel.bin中，我们必须打开A20，即CPU可以开始使用后面的12根地址线。此时，理论上，地址空间即达到了4G。&lt;/li&gt;
  &lt;li&gt;准备与加载全局段描述符（GDT）：由于保护模式和分段机制是CR0中的同一位，因此当我们设置了保护模式的标志位，同时我们也打开了分段机制。这表明我们必须在此之前设置好GDT表；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GDT表的设计：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;;
;进入保护模型，不再按照CS*16+IP取指令执行，需要按照向全局描述符
;
GDT0:
	DW      0x0000,0x0000,0x0000,0x0000
        ;---代码段基地址 0x0047取00，0x9a28取28，0x0000取全部===0x00280000
	DW	0xffff,0x0000,0x9a00,0x00cf
        ;---数据段基地址 0x00cf取00，0x9200取00，0x0000取全部===0x00000000
	DW	0xffff,0x0000,0x9200,0x00cf
        DW      0xffff,0x8000,0xf20b,0x000f
        ;为tss准备的
	DW      0x0000,0x0000,0x0000,0x0000
        ;为ldt准备的
	DW      0x0000,0x0000,0x0000,0x0000
        ;DW      0xffff,0x8000,0xf20b,0x000f
GDT0_LEN EQU $-GDT0
GDTR0:
	DW	GDT0_LEN-1
	DW      GDT0-0x7c00,0x9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GDT表中的表项其实就是限定该段的访问权限和访问地址空间。&lt;/p&gt;

&lt;p&gt;最后，最重要的一步：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV	CR0,EAX                 ;打开段级保护，不开分页机制
;程序执行到这里结束，跳转到init/kernel.asm（即移动到0x0处的代码）执行
JMP	dword 0x08:0x5000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理解这段代码，其实也是理解实模式和保护模式的寻址差异。&lt;/p&gt;

&lt;p&gt;这段代码表明：CS=0x8，offset=0x5000。&lt;/p&gt;

&lt;p&gt;关于CS、GDT在保护模式下的作用，这里不进行说明，直接告诉结果：0x08表明我们将跳转到GDT表现中的第一项，其基地址为0x00，加上偏移地址，即跳转的目的地址为0x5000。该内存空间即保存了前面所提到的kernel.bin代码。&lt;/p&gt;

&lt;p&gt;跳转后，保护模式下前面几段汇编代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;; 采用Intel汇编格式
_start:
	MOV	EAX,0x00000010
	MOV	DS,AX
	MOV	ES,AX
	MOV	FS,AX
	MOV	GS,AX
	MOV	SS,AX
; 设置页目录表和页目录
    CALL    setup_paging
; 开始打开分页机制
    XOR     EAX,EAX
    MOV     CR3,EAX ;将_page_dir地址0x0000写给CR3
    MOV     EAX,CR0
    OR      EAX,0x80000000
    MOV     CR0,EAX ;PG位置1
; 设置堆栈
	MOV     ESP,kernel_stack_top
    MOV     EBP,ESP

; 跳转到C语言部分
    MOV     EAX,kernel_start
    JMP     EAX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码最后会跳转到kernel_start函数处，自此，我们可以开始使用C语言编写后续的OS代码。在这里其余代码不做分析。&lt;/p&gt;

&lt;h3 id=&quot;内存管理&quot;&gt;内存管理&lt;/h3&gt;

&lt;p&gt;在内存管理模型中，尚未完成slab分配器这种优秀的内存分配算法。目前，我仅仅使用mem_map[]数据管理每一页，同时在需要动态分配指定大小的内存时，采用固定的几个page进行分配。&lt;/p&gt;

&lt;p&gt;总之，内存管理部分尚不完善，需要实现alloc和free的闭环，同时兼顾内存碎片等问题还需走很长的路。&lt;/p&gt;

&lt;h3 id=&quot;中断子系统&quot;&gt;中断子系统&lt;/h3&gt;

&lt;p&gt;在拷贝kernel.bin到0x00时，BIOS初始化的中断向量表就不能在使用，在完成进入保护模式的步骤后，需要马上建立保护模式下的中断子系统。&lt;/p&gt;

&lt;p&gt;统一的中断入口：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * 中断服务程序
 * 函数说明：识别到底是发生了说明中断（通过regs-&amp;gt;int_no），然后
 *	     执行相应的中断服务程序。
 * interrupt_handlers[n]是一个数组函数，n代表了具体的中断服务程
 * 序，函数参数为regs。
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isr_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_regs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt_handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;interrupt_handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 32号中断以后的中断入口 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;irq_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt_regs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;cm&quot;&gt;/* 
	 * 从32号开始，为用户自定义中断，单片只能处理八级中断，因此大于40是由从片处理 
	 */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_no&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;cm&quot;&gt;/* 发送重设信号给从片 */&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xa0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;cm&quot;&gt;/* 发送重设信号给主片 */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;outb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt_handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;interrupt_handlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;unhandle irq_handler:%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;中断向量表：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_idt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idt_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idt_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idt_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idt_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idt_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将中断向量表地址告诉LIDT寄存器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;load_idtr:
        MOV     EAX,[ESP+4]
        LIDT    [EAX]
        ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将中断向量表的地址告诉LIDT寄存器后，在使能中断并发生中断后，CPU即可根据中断向量表地址、以及所产生的中断号找到对应的中断服务函数。&lt;/p&gt;

&lt;h3 id=&quot;系统调用&quot;&gt;系统调用&lt;/h3&gt;

&lt;p&gt;为了实现不同进程间的切换，必须首先实现系统调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;;===========================================================================
;				sys_call
; 目前系统调用的函数定义和system_call_table数组在include/i386/sys.h下  
;
; 进入system_call：
;	eax system number
;	ebx arg1
;	ecx arg2
;	edx arg3
;	esi arg3
;	edi arg3
;	ebp arg4
;	
; 从系统调用返回是，栈分布如下：
;	 esp+0 - %eax
;	 esp+4 - %ebx
;	 esp+8 - %ecx
;	 esp+C - %edx
;	esp+10 - %fs
;	esp+14 - %es
;	esp+18 - %ds
;	esp+1C - %eip
;	esp+20 - %cs
;	esp+24 - %eflags
;	esp+28 - %oldesp
;	esp+2C - %oldss
;===========================================================================
; 系统调用入口函数
[GLOBAL system_call]
system_call:
;===========================================================================
; already on stack: ss,sp,flags,cs,ip
; next to save general register:EAX ECX EDX EBX ESP EBP ESI EDI and ds es fs gs
;===========================================================================
	pushad          ;  \
    push    ds      ;  |
    push    es      ;  | 保存原寄存器值
    push    fs      ;  |
    push    gs      ; /

	mov 	esi,esp
	
	mov	edx,0x10 ; 设置ds es段指向当前进程的内核态数据段
	mov 	ds,dx
	mov	es,dx

	mov 	edx,0x17 ; 设置fs段指向当前进程用户态数据段
	mov 	fs,dx

	sti
    call    [system_call_table + eax * 4]
    ; why add esi to 11*4 ? --&amp;gt; from EAX to gs has 11*4 
    mov     [esi + 11*4], eax
	cli
	
        ; 检测当前进程是否处于就绪态（state），时间片是否用完
        ; if state == TASK_RUNNING, then the task would be rescheduled
.2: mov 	eax,current
    cmp	dword [eax],0
    jne	reschedule
    cmp	dword [eax+4],0
    je 	reschedule
ret_from_system_call:
	;add	esp, 4 * 4
	;pop	esi
	pop	gs
	pop	fs
	pop	es
	pop	ds
	popad
	
        ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;进程模型&quot;&gt;进程模型&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h3 id=&quot;调度&quot;&gt;调度&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;项目主页：&lt;a href=&quot;https://github.com/wangrongwei/UNIX386&quot;&gt;UNIX386&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;https://wiki.osdev.org/Main_Page&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 20 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/06/20/UNIX386.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/06/20/UNIX386.html</guid>
        
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>内核问题很“内核”</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/04/11/linux-kernel-problems.html&quot;&gt;http://wangrongwei.com/2020/04/11/linux-kernel-problems.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;内核栈是什么？用户栈是什么？&lt;/li&gt;
  &lt;li&gt;进程上下文是什么？中断上下文是什么？&lt;/li&gt;
  &lt;li&gt;为什么中断上下文中不能发生睡眠？&lt;/li&gt;
  &lt;li&gt;为什么自旋锁不能睡眠？&lt;/li&gt;
  &lt;li&gt;逻辑地址、虚拟地址、物理地址是什么？&lt;/li&gt;
  &lt;li&gt;用户态是什么？内核态是什么？&lt;/li&gt;
  &lt;li&gt;用户抢占是什么？内核抢占是什么？&lt;/li&gt;
  &lt;li&gt;超线程是什么？同时多线程（SMT）是什么？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;关联链接&quot;&gt;关联链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;http://www.wangrongwei.com//tech/the-simple-module-of-task-switch/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 11 Apr 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/04/11/linux-kernel-problems.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/04/11/linux-kernel-problems.html</guid>
        
        <category>programming</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>走进电影</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;看过很多电影，不过也忘得差不多了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部
作者：lollipop
本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/04/07/walking-with-film.html&quot;&gt;http://wangrongwei.com/2020/04/07/walking-with-film.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一代宗师&quot;&gt;一代宗师&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;见自己，见天地，见众生&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;前几日，我又重看了关于《一代宗师》电影的解说，然后就记住了这句话。这句话大概意思很明显，但是应该很难做到，我应该还处在“见自己”时间，估计“见众生”估计也就是圣人了。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 07 Apr 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/04/07/walking-with-film.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/04/07/walking-with-film.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>一个简单的多任务切换模型</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;多任务切换的简单模型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/04/04/the-simple-module-of-task-switch.html&quot;&gt;http://wangrongwei.com/2020/04/04/the-simple-module-of-task-switch.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在单核时代，单个进程独占一个CPU不能充分利用CPU计算能力，其中存在大量的IO等待、网络、磁盘等操作，闲置了CPU。因此，若当当前进程因等待IO的时候，CPU可以切换到另一个进程，完成另一进程的计算部分，当前一个进程IO数据返回，CPU再重新恢复该进程的上下文并继续执行后续进程代码。以上整个过程就是目前计算机中进程切换的最简单模型。本文主要对两个进程在CPU上”无缝“切换进行描述，本文后续采用切换模型或模型表示整个切换机制。&lt;/p&gt;

&lt;h2 id=&quot;直奔切换模型&quot;&gt;直奔切换模型&lt;/h2&gt;

&lt;p&gt;在一个运行操作系统的计算机上，CPU在任一时刻处于用户态或者内核态两者之一，并在这两者之间不断的切换。在切换模型中，仅仅只有当CPU处于内核态时，才能执行进程切换，并在回到用户态以后才真正开始执行新“上任”的进程。&lt;/p&gt;

&lt;p&gt;在这里，我尝试用一张简单的图进行来说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://wangrongwei.com/images/switch-task.svg&quot; alt=&quot;svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，没有提到具体的寄存器名，采用了一种比较通用的办法表示各种参与者，比如：&lt;/p&gt;

&lt;p&gt;1）T：表示时刻，其中T1、T2分别表示进程执行系统调用进入内核态或返回用户态的两个时刻；&lt;/p&gt;

&lt;p&gt;2）R1：表示寄存器，主要当CPU进入内核态时，记录当前的进程上下文（记录了一个进程的所有数据和资源）；&lt;/p&gt;

&lt;p&gt;3）P1：触发事件，比如当task1的时间片用完，将会主动让出CPU；&lt;/p&gt;

&lt;p&gt;接下来，用两个函数来实现P1发生后，如何切换R1：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;cm&quot;&gt;/*
  * 切换进程
  * 保存eflags
  */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define switch_to(prev,next,last) do {					\
	unsigned long esi,edi;						\
	__asm__ __volatile__(&quot;pushfl\n\t&quot;	&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 保存eflags */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;		\
		     &quot;pushl %%ebp\n\t&quot;					\
		     &quot;movl %%esp,%0\n\t&quot;	&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 保存ESP */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;		\
		     &quot;movl %5,%%esp\n\t&quot;	&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 切换ESP */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;		\
		     &quot;movl $1f,%1\n\t&quot;		&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 保存EIP */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;		\
		     &quot;pushl %6\n\t&quot;		&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 切换EIP */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;		\
		     &quot;jmp __switch_to\n&quot;				\
		     &quot;1:\t&quot;			&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 下一次切换回到1 */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;		\
		     &quot;popl %%ebp\n\t&quot;					\
		     &quot;popfl&quot;						\
		     :&quot;=m&quot; (prev-&amp;gt;tss.esp0),&quot;=m&quot; (prev-&amp;gt;tss.eip),	\
		      &quot;=a&quot; (last),&quot;=S&quot; (esi),&quot;=D&quot; (edi)			\
		     :&quot;m&quot; (next-&amp;gt;tss.esp0),&quot;m&quot; (next-&amp;gt;tss.eip),		\
		      &quot;2&quot; (prev), &quot;d&quot; (next));				\
} while (0)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的switch_to函数中prev代表上一个进程、next代表下一个进程。在整个宏定义中，jmp __switch_to便是去执行另一个进程的程序，在跳转前需要做的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;保存当前进程上下文到prev，其中的EIP保存就是&lt;strong&gt;movl $1f, %1\n\t&lt;/strong&gt;，即是将&lt;strong&gt;“1:\t”&lt;/strong&gt;的位置记录下来，下一次该进程切换回时，便从&lt;strong&gt;“1:\t”&lt;/strong&gt;位置开始。&lt;/li&gt;
  &lt;li&gt;开始跳转到&lt;strong&gt;__switch_to&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面一段代码是&lt;strong&gt;__switch_to&lt;/strong&gt;的代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
  * 切换到task_[n]，首先需要检测n不是当前current，否则不做任何事；
  * 如果task_[n]用到math co-processor，需要清空TS-flag；
  */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fastcall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__switch_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;__asm__&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__volatile__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cli&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;mov %0, %%ecx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;mov %1, %%esp&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;mov %2, %%ebp&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;mov %3, %%eax&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;mov $0x12345, %%eax&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;sti&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;s&quot;&gt;&quot;jmp *%%ecx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; \
		&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cr3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;strong&gt;__switch_to&lt;/strong&gt;便从完成next进程的跳转过程，跳转代码即是&lt;strong&gt;“jmp *%%ecx\t”&lt;/strong&gt;，可以简单想想一下，若该进程若不是第一次进入CPU，那这一行跳转代码将会跳转到该进程的&lt;strong&gt;“1:\t”&lt;/strong&gt;位置。&lt;/p&gt;

&lt;p&gt;内核的调度系统是一个特别复杂的过程，在这里仅仅展示了多个进程间切换的过程，其模型基本与linux-0.1.1中调度代码差不多，虽然简单，但基本表示了CPU是如何做到“无缝”切换进程的过程。&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;FAQ&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;什么时候进行执行进程切换？&lt;/p&gt;

    &lt;p&gt;执行系统调用或中断进入内核态以后。在进入内核态以后都可以设置进程是否需要切换的判断。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何做到无缝衔接？&lt;/p&gt;

    &lt;p&gt;这里的无缝仅仅停留在基本的切换上，如&lt;strong&gt;switch_to&lt;/strong&gt;与&lt;strong&gt;__switch_to&lt;/strong&gt;两个函数，可以概括为何时跳转、又如何跳转回。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户态与内核态如何切换？&lt;/p&gt;

    &lt;p&gt;系统调用或者发送中断。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;

&lt;p&gt;本文所涉及的代码来自我编写的UNIX386内核。&lt;/p&gt;

</description>
        <pubDate>Sat, 04 Apr 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/04/04/the-simple-module-of-task-switch.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/04/04/the-simple-module-of-task-switch.html</guid>
        
        <category>programming</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>ARM64仿真</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;内核开发前的虚拟机搭建&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部&lt;/p&gt;

  &lt;p&gt;作者：lollipop&lt;/p&gt;

  &lt;p&gt;本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/03/15/ARM64-simulation.html&quot;&gt;http://wangrongwei.com/2020/03/15/ARM64-simulation.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h2&gt;

&lt;p&gt;在内核开发中，我们经常在虚拟机环境中开发内核模块或直接修改内核代码，以及backport社区的补丁。&lt;/p&gt;

&lt;p&gt;本文介绍内核开发者的虚拟机开发环境。&lt;/p&gt;

&lt;h3 id=&quot;安装qemu&quot;&gt;安装qemu&lt;/h3&gt;

&lt;p&gt;可选择一下版本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://download.qemu.org/qemu-4.2.0.tar.xz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来，进入qemu目录，执行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure &lt;span class=&quot;nt&quot;&gt;--enable-virtfs&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enable-debug&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span class=&quot;nt&quot;&gt;-j4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;未指明–target-list表示配置所有架构。&lt;/p&gt;

&lt;h3 id=&quot;制作文件系统&quot;&gt;制作文件系统&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下载&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，选择busybox制作文件系统，需要先安装busybox，可下载如下版本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://busybox.net/downloads/busybox-1.24.2.tar.bz2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来，需要对busybox进行配置，执行make menuconfig命令进行配置，以下两个选项需要设置：&lt;/p&gt;

&lt;p&gt;Busybox Setting -&amp;gt; Build Options -&amp;gt; static binary(enable)&lt;/p&gt;

&lt;p&gt;Networking Utilities -&amp;gt; inetd(disable)&lt;/p&gt;

&lt;p&gt;Busybox Setting -&amp;gt; BusyBox installation prefix(../rootfs)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make &lt;span class=&quot;nv&quot;&gt;ARCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;arm64 &lt;span class=&quot;nv&quot;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;aarch64-linux-gnu-
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在当前文件的上一级目录下生成rootfs文件。接下来需要在rootfs中添加必要的文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;制作文件系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进入rootfs，执行以下命令&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;dev etc mnt
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; etc/init.d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进入etc/init.d中创建文件rcS，在文件中加入以下内容，并修改rcS为可执行。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /proc
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /tmp
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /sys
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /mnt
/bin/mount &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /dev/pts
mount &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; devpts devpts /dev/pts
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; /sbin/mdev &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/kernel/hotplug
mdev &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在etc/目录下新建一个fstab文件，加入内容如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proc /proc proc defaults 0 0 
tmpfs /tmp tmpfs defaults 0 0 
sysfs /sys sysfs defaults 0 0 
tmpfs /dev tmpfs defaults 0 0
debugfs /sys/kernel/debug debugfs defaults 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在etc/ 目录下新建一个inittab文件，加入以下内容：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;::sysinit:/etc/init.d/rcS 
::respawn:-/bin/sh 
::askfirst:-/bin/sh 
::ctrlaltdel:/bin/umount &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在dev目录下执行以下命令&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mknod &lt;/span&gt;console c 5 1 
&lt;span class=&quot;nb&quot;&gt;mknod &lt;/span&gt;null c 1 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在rootfs目录执行以下命令&lt;/p&gt;

&lt;p&gt;find . | cpio -o -H newc &amp;gt; rootfs.cpio 
gzip -c rootfs.cpio &amp;gt; rootfs.cpio.gz
至此，rootfs中的rootfs.cpio.gz就是制作好的文件系统&lt;/p&gt;

&lt;p&gt;后续将以上操作写成shell脚本，可参考：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/gengcixi/build-busybox
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;制作linux内核&quot;&gt;制作Linux内核&lt;/h3&gt;

&lt;p&gt;可选择以下内核版本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.99.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来，进入Linux目录，执行以下命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make &lt;span class=&quot;nv&quot;&gt;ARCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;arm64 &lt;span class=&quot;nv&quot;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;aarch64-linux-gnu- defconfig
make &lt;span class=&quot;nv&quot;&gt;ARCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;arm64 &lt;span class=&quot;nv&quot;&gt;CROSS_COMPILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;aarch64-linux-gnu- Image &lt;span class=&quot;nt&quot;&gt;-j8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译成功的内核为arch/arm64/boot/Image&lt;/p&gt;

&lt;h2 id=&quot;虚拟机管理&quot;&gt;虚拟机管理&lt;/h2&gt;

&lt;h3 id=&quot;制作镜像&quot;&gt;制作镜像&lt;/h3&gt;

&lt;p&gt;使用qemu-img制作镜像&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-img create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; qcow2 centos7-aarch64.img 10G
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动虚拟机&quot;&gt;启动虚拟机&lt;/h3&gt;

&lt;p&gt;将以上生成的Image文件和rootfs.cpio.gz拷贝到单独的文件下，执行以下命令启动linux内核：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-aarch64 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-cpu&lt;/span&gt; cortex-a57 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-machine&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;virt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-smp&lt;/span&gt; 1 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 512 &lt;span class=&quot;nt&quot;&gt;-kernel&lt;/span&gt; Image &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-append&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;rdinit=/linuxrc console=ttyAMA0&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-initrd&lt;/span&gt; rootfs.cpio.gz &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-scsi-device
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;网络配置&quot;&gt;网络配置&lt;/h3&gt;

&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;

&lt;p&gt;qemu两种上网方式：&lt;/p&gt;

&lt;p&gt;　　1）user mode network :&lt;/p&gt;

&lt;p&gt;　　这种方式实现虚拟机上网很简单，类似vmware里的nat，qemu启动时加入-user-net参数，虚拟机里使用dhcp方式，即可与互联网通信，但是这种方式虚拟机与主机的通信不方便。&lt;/p&gt;

&lt;p&gt;　　2）tap/tun network :&lt;/p&gt;

&lt;p&gt;　　这种方式要比user mode复杂一些，但是设置好后 虚拟机&amp;lt;–&amp;gt;互联网 虚拟机&amp;lt;–&amp;gt;主机 通信都很容易。这种方式设置上类似vmware的host-only,qemu使用tun/tap设备在主机上增加一块虚拟网络设备(tun0),然后就可以象真实网卡一样配置它。&lt;/p&gt;

&lt;p&gt;如何在虚拟机内核连接外网？&lt;/p&gt;

&lt;p&gt;QEMU虚拟机网络的缺省模式是NAT方式，即虚拟机可以通过host访问外网，但host和外网无法访问虚拟机。如果要想让host访问虚拟机，则可以使用TAP方式。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;首先，需要安装tunctl，可采用**lsmod&lt;/td&gt;
      &lt;td&gt;grep tun**确认系统是否已经安装tun模块，若内核模块已经安装，可继续安装tunctl。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;编写QEMU的TAP初始化脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;QEMU的TAP初始化脚本缺省是 /etc/qemu-ifup，它的内容很简单：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
/sbin/ifconfig &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; 192.168.0.118
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中192.168.0.118与host的ip地址需在不同网段，另外，/etc/qemu-ifup文件需要增加可执行的权限。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚拟机的网络设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚拟机的启动命令行增加网络参数：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;-net&lt;/span&gt; nic &lt;span class=&quot;nt&quot;&gt;-net&lt;/span&gt; tap
待测试的：
&lt;span class=&quot;nt&quot;&gt;-net&lt;/span&gt; nic &lt;span class=&quot;nt&quot;&gt;-net&lt;/span&gt; tap,ifname&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;tap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即可启动TAP网络模式。注意：因为创建TAP网卡需要root权限，所以必须用root用户启动QEMU。虚拟机启动后，用ifconfig命令设置网络，要求它的IP与host的tap网口的IP（即在上个步骤里qemu-ifup文件中设置的IP）处于同一网段。例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig eth0 192.168.0.119 netmask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;

&lt;p&gt;在Windows上使用qemu虚拟机，通过此配置，可以使qemu中的虚拟机能连接互联网，并且也可以和Windows主机通信。此方式类似于Vmware和VitrualBox中的桥接网卡。配置方法如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;在Windows主机上安装TAP网卡驱动:&lt;/strong&gt; 可下载openvpn客户端软件，只安装其中的TAP驱动；在网络连接中，会看到一个新的网卡，属性类似于TAP-Win32 Adapter…，将其名称修改为tap0。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;将tap0虚拟网卡和Windows上连接互联网的真实网卡桥接:&lt;/strong&gt; 选中这两块网卡，右键，桥接。此时，Windows主机将不能连接互联网。重新连接WIFI使Windows主机连接互联网。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;qemu配置:&lt;/strong&gt; 在虚拟机启动命令行添加以下参数：–net nic -net tap,ifname=tap0；启动虚拟机，并配置虚拟机中的网卡，则虚拟机也可以和Windows主机一样，连接互联网和Windows主机。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;启动centos或openeuler&quot;&gt;启动CentOS或openEuler&lt;/h2&gt;

&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;在编译和最后的执行内核过程中，若出现问题，可采用**file&lt;/td&gt;
      &lt;td&gt;which**两个命令对生成的可执行文件进行查看。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;按Ctrl+A+X组合键退出qemu模拟器
按Ctrl+A+C组合键进入qemu-monitor，输入help可以查看操作命令&lt;/p&gt;

&lt;p&gt;以上满足基本的aarch64开发环境需求，需另外补充：&lt;/p&gt;

&lt;p&gt;首次安装虚拟机，采用脚本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-aarch64 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 2048 &lt;span class=&quot;nt&quot;&gt;-cpu&lt;/span&gt; cortex-a57 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-smp&lt;/span&gt; 2 &lt;span class=&quot;nt&quot;&gt;-M&lt;/span&gt; virt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-bios&lt;/span&gt; edk2-aarch64-code.fd &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-drive&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;none,file&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ubuntu-18.04.4-server-arm64.iso,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cdrom,media&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cdrom &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-scsi-device &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; scsi-cd,drive&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cdrom &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-drive&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;none,file&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;CentOS7-arm64.qcow2,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-blk-device,drive&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;edk2-aarch64-code.fd文件来自qemu安装目录。&lt;/p&gt;

&lt;p&gt;后续再使用时，可采用脚本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-aarch64 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 2048 &lt;span class=&quot;nt&quot;&gt;-cpu&lt;/span&gt; cortex-a57 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-smp&lt;/span&gt; 2 &lt;span class=&quot;nt&quot;&gt;-M&lt;/span&gt; virt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-bios&lt;/span&gt; edk2-aarch64-code.fd &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-scsi-device &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-drive&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;qcow2,media&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;disk,cache&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;writeback,if&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;none,file&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;CentOS7-arm64.qcow2,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-blk-device,drive&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;两个脚本分开，以防止在后续使用过程中重复安装操作。&lt;/p&gt;

&lt;h2 id=&quot;faq&quot;&gt;FAQ&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如何制作rootfs文件系统？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;改变方案，用现有发行版的arm64取代？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failed to set MokListRT: Invalid Parameter（-bios后的fd文件不对）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何在qemu虚拟机内连接网络？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在虚拟机中键盘不匹配，无法使用vim&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机无法ping通host，host可以ping通虚拟机？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检测路由：route -v，缺少到目的IP的路由时，采用以下命令进行添加：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;route add &lt;span class=&quot;nt&quot;&gt;-net&lt;/span&gt; 192.168.62.0 netmask 255.255.255.0 gw 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其他启动脚本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-aarch64 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-machine&lt;/span&gt; virt-3.1 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-smp&lt;/span&gt; 8 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 1G,slots&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2,maxmem&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3G &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-enable-kvm&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-cpu&lt;/span&gt; host &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-drive&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;none,file&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ubuntu-16.04-server-cloudimg-arm64-uefi1.img,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-monitor&lt;/span&gt; unix:qemu-monitor-socket,server,nowait &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-blk-device,drive&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-qmp&lt;/span&gt; unix:./qmp-sock,server,nowait &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-qmp&lt;/span&gt; tcp:localhost:6666,server,nowait &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; pcie-pci-bridge,bus&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pcie.0,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pcie-bridge-0,msi&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;on,x-pcie-lnksta-dllla&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;on,addr&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2,romfile&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; pci-bridge,bus&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pcie-bridge-0,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pci.0,shpc&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;on,msi&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;on,chassis_nr&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1,addr&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-pflash&lt;/span&gt; flash0.img &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-pflash&lt;/span&gt; flash1.img &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;-netdev&lt;/span&gt; user,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;user0 &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-net-device,netdev&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;user0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://luomuxiaoxiao.com/?p=743&lt;/li&gt;
  &lt;li&gt;https://blog.csdn.net/linsheng_111/article/details/82996347&lt;/li&gt;
  &lt;li&gt;https://blog.csdn.net/wujianyongw4/article/details/90289208&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/03/15/ARM64-simulation.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/03/15/ARM64-simulation.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>如何使用该主题？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;如何使用该主题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部
作者：lollipop
本文原文地址：&lt;a href=&quot;http://wangrongwei.com/2020/03/14/using-this.html&quot;&gt;http://wangrongwei.com/2020/03/14/using-this.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;ruby包下载&quot;&gt;ruby包下载&lt;/h2&gt;

&lt;p&gt;jekyll依赖于ruby安装包，需前往&lt;a href=&quot;https://rubyinstaller.org/downloads/&quot;&gt;l&lt;/a&gt;下载较新的安装包。&lt;/p&gt;

&lt;h2 id=&quot;修改源&quot;&gt;修改源&lt;/h2&gt;

&lt;p&gt;在进行后续步骤前，需要对ruby源进行更新，否则后续下载相关包将花费不少的时间，源更改操作如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- gem sources &lt;span class=&quot;nt&quot;&gt;--add&lt;/span&gt; https://gems.ruby-china.com/ &lt;span class=&quot;nt&quot;&gt;--remove&lt;/span&gt; https://rubygems.org/
- gem sources &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过以上操作，使用&lt;strong&gt;gem sources -l&lt;/strong&gt;查看仅存在新添加的淘宝源。&lt;/p&gt;

&lt;h2 id=&quot;jekyll-and-bundler-安装&quot;&gt;jekyll and bundler 安装&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;jekyll bundler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;选择主题&quot;&gt;选择主题&lt;/h2&gt;

&lt;p&gt;目前，网上有开源的博客主题，可前面&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;jekyllthemes&lt;/a&gt;选择喜欢的主题下载。该博客选择的主题是&lt;strong&gt;skinny-bones-jekyll&lt;/strong&gt;，其作者的主页如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mademistakes.com/&quot;&gt;A Jekyll starter site&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;除以上主题外，作者也提供了其他供选择的主题。&lt;/p&gt;

&lt;h2 id=&quot;配置概述&quot;&gt;配置概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;_config.yml&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要配置文件，用户可修改站点名、邮件、Github等信息。&lt;/p&gt;

&lt;p&gt;以下为disqus评论系统配置信息：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;disqus_username: 你的Username
disqus: Evan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用户在使用该主题前，必须对其进行修改或空置，该项勿随机配置。若需要保留该配置，需前往disqus官网进行注册（需VPN）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;blog.md&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客，对博客文章进行展示，在本主题中包括博客、学术、工程三类，对其进行分开展示。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;notice.md&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客说明。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;index.md&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首页，主要对include目录下的index.html进行引用，可以进行优化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CNAME&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;个性域名，需要使用者自己购买域名配置在此处配置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Evan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该主题名，用户可第一时间修改。&lt;/p&gt;

&lt;h2 id=&quot;配置说明&quot;&gt;配置说明&lt;/h2&gt;

&lt;p&gt;待补充。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;若使用者对jekyll的语法不够熟悉，且计划对代码和布局进行修改，推荐先阅读jekyll提供的&lt;a href=&quot;https://jekyllrb.com/docs/step-by-step/01-setup/&quot;&gt;step-by-step&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;enjoy!&lt;/p&gt;

&lt;h2 id=&quot;相关引用&quot;&gt;相关引用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.jekyll.com.cn/docs/&quot;&gt;https://www.jekyll.com.cn/docs/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://rubyinstaller.org/downloads/&quot;&gt;https://rubyinstaller.org/downloads/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://gems.ruby-china.com/&quot;&gt;https://gems.ruby-china.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;http://jekyllthemes.org/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 14 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://wangrongwei.com/2020/03/14/using-this.html</link>
        <guid isPermaLink="true">http://wangrongwei.com/2020/03/14/using-this.html</guid>
        
        
        <category>project</category>
        
      </item>
    
  </channel>
</rss>
