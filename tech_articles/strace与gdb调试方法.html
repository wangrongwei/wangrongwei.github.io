<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>strace与gdb调试方法</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2><a id="linux_0"></a>linux下调试技巧</h2>
<p>这几天一直在找关于介绍linux下调试工具与调试方法的书，然后找到了《hack and debug》，这本书介绍特别多的工具对linux程序进行调试。对于驱动开发特别有用，最开始作者一直认为驱动调试与应用程序调试不一样，但是研究研究strace和gdb联合调试后，发现如果驱动程序出现Bug，调试它的测试程序时，会找到这个有bug的驱动接口。<br>
当然这本书写作时间比较早，linux更新又快，所以有些指令使用方法有些变动。</p>
<hr>
<h2><a id="strace_7"></a>strace</h2>
<ol>
<li>有bug的程序</li>
</ol>
<pre><code>
/*
 * 内核调试使用 strace
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
	//int fd;
	//printf("we want to open a file\n");
	int fd;
    // bug：吴权限访问/etc/gshadow
	fd = fopen("/etc/gshadow","r");
	//printf("we want to open a file\n");
	if(fd == NULL){
		printf("Error!\n");
		//return EXIT_SUCCESS;
	}
		
	return EXIT_SUCCESS;
}

</code></pre>
<ul>
<li>程序说明<br>
在无权限的时候访问/etc目录下的文件节点，肯定会出错。但是对于普通的驱动测试程序，无法预知程序在哪出错，当然可以加判断和大量的prinf来打印程序信息，但是这样麻烦。因此需要使用strace先跟踪程序运行，找到出现问题的API和运行地址，然后使用gdb深入到驱动程序（主要目的），当然使用gdb深入到驱动程序是作者的理解，需要实战一下才知道可不可行。</li>
</ul>
<ol start="2">
<li>strace ./st1<br>
跟踪当前目录下的st1程序，打印出数据：</li>
</ol>
<blockquote>
<p>execve("./st1", ["./st1"], [/* 79 vars */]) = 0<br>
brk(NULL)                               = 0x73f000<br>
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br>
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4aa58df000<br>
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)<br>
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3<br>
fstat(3, {st_mode=S_IFREG|0644, st_size=195135, …}) = 0<br>
mmap(NULL, 195135, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f4aa58af000<br>
close(3)                                = 0<br>
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br>
open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3<br>
read(3, “\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0”…, 832) = 832<br>
fstat(3, {st_mode=S_IFREG|0755, st_size=1868984, …}) = 0<br>
mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f4aa52f2000<br>
mprotect(0x7f4aa54b2000, 2097152, PROT_NONE) = 0<br>
mmap(0x7f4aa56b2000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) = 0x7f4aa56b2000<br>
mmap(0x7f4aa56b8000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f4aa56b8000<br>
close(3)                                = 0<br>
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4aa58ae000<br>
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4aa58ad000<br>
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f4aa58ac000<br>
arch_prctl(ARCH_SET_FS, 0x7f4aa58ad700) = 0<br>
mprotect(0x7f4aa56b2000, 16384, PROT_READ) = 0<br>
mprotect(0x600000, 4096, PROT_READ)     = 0<br>
mprotect(0x7f4aa58e1000, 4096, PROT_READ) = 0<br>
munmap(0x7f4aa58af000, 195135)          = 0<br>
brk(NULL)                               = 0x73f000<br>
brk(0x760000)                           = 0x760000<br>
open("/etc/gshadow", O_RDONLY)          = -1 EACCES (Permission denied)<br>
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), …}) = 0<br>
write(1, “Error!\n”, 7Error!<br>
)                 = 7<br>
nanosleep({3, 0}, 0x7ffe8901d6b0)       = 0</p>
</blockquote>
<ul>
<li>说明<br>
打印的确够多的，其实就是显示出st1程序在加载、运行过程中，调用系统接口或者库函数的顺序，发现:</li>
</ul>
<blockquote>
<p>open("/etc/gshadow", O_RDONLY)          = -1 EACCES (Permission denied)</p>
</blockquote>
<p>问题找到了，还可以知道运行这一行的地址。</p>
<ol start="2">
<li>strace -i ./st1<br>
带地址打印上面的信息。截一段打印：</li>
</ol>
<blockquote>
<p>[00007f365cfd0010] open("/etc/gshadow", O_RDONLY) = -1 EACCES (Permission denied)<br>
[00007f365cfcfc04] fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), …}) = 0<br>
[00007f365cfd0290] write(1, “Error!\n”, 7Error!<br>
) = 7<br>
[00007f365cfa52f0] nanosleep({3, 0}, 0x7ffed49a3c70) = 0</p>
</blockquote>
<h2><a id="stracegdb_94"></a>strace联合gdb</h2>
<p>在上面strace使用过程中，得到了程序出问题的地址0x00007f365cfd0010</p>
<ul>
<li>
<p>gcc -g -o st1 st1.c<br>
重新编译st1.c，加上-g选项（带上调试信息），否则在使用gdb会出现没有debug symbol。</p>
</li>
<li>
<p>gcc st1<br>
这个指令运行gcc，但是调试没有开始</p>
</li>
<li>
<p>start<br>
最开始有一个自动断点在main函数第一个调用上，输入start后停在main函数第一个调用上。</p>
</li>
<li>
<p>b *0x00007f365cfd0010<br>
在0x00007f365cfd0010设置一个断点，然后可以使用s或者c，这里不对其他gdb指令说明。</p>
</li>
</ul>
</div>
</body>

</html>
